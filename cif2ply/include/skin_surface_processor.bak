#ifndef CGAL_SKIN_SURFACE_PROCESSOR_H
#define CGAL_SKIN_SURFACE_PROCESSOR_H

#include <CGAL/Surface_mesh_simplification/edge_collapse.h>
#include <CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Count_stop_predicate.h>

#include "geo_tools.h"

namespace SMS = CGAL::Surface_mesh_simplification;

template<class Polyhedron>
/// Process polyhedron for SH coefficients:
void process_polyhedron(Polyhedron &p) {
    typedef K::Point_3 Point_3;

    const std::size_t edge_count_threshold = 10000;
    SMS::Count_stop_predicate<Polyhedron> stop(edge_count_threshold);

    int r = SMS::edge_collapse(p, stop,
                               CGAL::parameters::vertex_index_map(get(CGAL::vertex_external_index, p))
                                       .halfedge_index_map(get(CGAL::halfedge_external_index, p)));
    std::cout << "Finished!\n" << r << " edges removed.\n"
              << (p.size_of_halfedges() / 2) << " final edges.\n";

    typedef typename Polyhedron::Facet_iterator Facet_iterator;

    std::ofstream out("alm.csv");
    const int N = 16;
    for (int l=0; l<=N; l++) {
        for (int m = -l; m <= l; m++) {
            // Integrator
            double total = 0.0;
            for (Facet_iterator f = p.facets_begin(); f != p.facets_end(); ++f) {
                FT area = K::Compute_area_3()(f->halfedge()->vertex()->point(),
                                              f->halfedge()->next()->vertex()->point(),
                                              f->halfedge()->opposite()->vertex()->point());

                Point_3 centroid = K::Construct_centroid_3()(f->halfedge()->vertex()->point(),
                                                             f->halfedge()->next()->vertex()->point(),
                                                             f->halfedge()->opposite()->vertex()->point());

                auto rtp = xyz2rtp(centroid);

                total += rtp.radius * ylm(l, m, rtp.theta, rtp.phi) * area;
                std::cout << "(" << centroid << ") "
                          << area << " (" << rtp.radius << " " << rtp.theta << " " << rtp.phi << ") "
                          << ylm(l, m, rtp.theta, rtp.phi) << std::endl;
            }
            out << l << "," << m << "," << total << std::endl;
        }
    }
    out.close();

}


#endif // CGAL_SKIN_SURFACE_PROCESSOR_H
